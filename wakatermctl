#!/usr/bin/env python3
"""
WakaTermCtl - Terminal Stats Viewer for WakaTerm NG
A command-line tool to view your terminal activity statistics from local logs
"""
#why? cos API too complicated
# NOTE: Many parts of this script was generated by GitHub Copilot because manual labour was hard :pf:

import os
import sys
import json
import argparse
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional
from collections import defaultdict, Counter


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'

    # Text colors
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    GRAY = '\033[90m'

    # Bright colors
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'

    @staticmethod
    def disable():
        """Disable colors for non-terminal output"""
        for attr in dir(Colors):
            if not attr.startswith('_') and attr != 'disable':
                setattr(Colors, attr, '')


class LocalStatsReader:
    """Reads and analyzes terminal activity from local log files"""

    def __init__(self, log_dir: Optional[str] = None):
        self.log_dir = Path(log_dir or os.path.expanduser('~/.local/share/wakaterm-logs'))

    def _apply_filters(self, entries: List[Dict], filters: Dict) -> List[Dict]:
        """Apply filters to log entries"""
        filtered = entries

        if filters.get('project'):
            project_filter = filters['project'].lower()
            filtered = [e for e in filtered if project_filter in e.get('project', '').lower()]

        if filters.get('language'):
            lang_filter = filters['language'].lower()
            filtered = [e for e in filtered if lang_filter in e.get('language', '').lower()]
        
        if filters.get('command'):
            import fnmatch
            cmd_pattern = filters['command']
            filtered = [e for e in filtered if fnmatch.fnmatch(e.get('base_command', ''), cmd_pattern)]
        
        if filters.get('min_time'):
            min_time = filters['min_time']
            filtered = [e for e in filtered if e.get('duration', 2.0) >= min_time]
        
        return filtered
    
    def _read_log_files(self, start_date: datetime, end_date: datetime) -> List[Dict]:
        """Read log entries from files within date range"""
        entries = []
        
        if not self.log_dir.exists():
            return entries
            
        # list of dates to check
        current_date = start_date.date()
        end_date_only = end_date.date()
        
        while current_date <= end_date_only:
            log_file = self.log_dir / f"wakaterm-{current_date.strftime('%Y-%m-%d')}.jsonl"
            if log_file.exists():
                try:
                    with open(log_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            line = line.strip()
                            if line:
                                try:
                                    entry = json.loads(line)
                                    entry_time = datetime.fromtimestamp(entry['timestamp'])
                                    if start_date <= entry_time <= end_date:
                                        entries.append(entry)
                                except (json.JSONDecodeError, KeyError, ValueError):
                                    continue
                except Exception:
                    continue
            current_date += timedelta(days=1)
                    
        return entries
    
    def get_stats_for_period(self, period: str, filters: Optional[Dict] = None) -> Dict:
        """Get stats for a specific period"""
        now = datetime.now()
        
        if period == "today":
            start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "yesterday":
            yesterday = now - timedelta(days=1)
            start_date = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = yesterday.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == "last_7_days":
            start_date = (now - timedelta(days=7)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_30_days":
            start_date = (now - timedelta(days=30)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_6_months":
            start_date = (now - timedelta(days=180)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_year":
            start_date = (now - timedelta(days=365)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        else:
            # Default to today
            start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        
        entries = self._read_log_files(start_date, end_date)
        
        # Apply filters if provided
        if filters:
            entries = self._apply_filters(entries, filters)
            
        return self._calculate_stats(entries, period)
    
    def _calculate_stats(self, entries: List[Dict], period: str) -> Dict:
        """Calculate statistics from log entries"""
        if not entries:
            return {"data": None}
        
        # Count entries by various dimensions
        language_counts = Counter()
        project_counts = Counter()
        command_counts = Counter()
        daily_counts = defaultdict(int)
        hourly_counts = defaultdict(int)
        
        total_commands = len(entries)
        total_seconds = sum(entry.get('duration', 2.0) for entry in entries)
        
        # Time tracking
        timestamps = [entry['timestamp'] for entry in entries]
        first_activity = datetime.fromtimestamp(min(timestamps)) if timestamps else None
        last_activity = datetime.fromtimestamp(max(timestamps)) if timestamps else None
        
        # Session tracking (gaps > 15 minutes indicate new session)
        sessions = []
        if timestamps:
            sorted_times = sorted(timestamps)
            session_start = sorted_times[0]
            
            for i in range(1, len(sorted_times)):
                if sorted_times[i] - sorted_times[i-1] > 900:  # 15 minutes gap
                    sessions.append((session_start, sorted_times[i-1]))
                    session_start = sorted_times[i]
            sessions.append((session_start, sorted_times[-1]))
        
        for entry in entries:
            language = entry.get('language', 'Unknown')
            project = entry.get('project', 'Unknown')
            base_command = entry.get('base_command', 'unknown')
            timestamp = entry['timestamp']
            duration = entry.get('duration', 2.0)
            
            language_counts[language] += duration
            project_counts[project] += duration
            command_counts[base_command] += 1
            
            # Daily and hourly breakdown
            entry_datetime = datetime.fromtimestamp(timestamp)
            entry_date = entry_datetime.date()
            entry_hour = entry_datetime.hour
            
            daily_counts[entry_date] += duration
            hourly_counts[entry_hour] += duration
        
        # Calculate various averages and metrics
        days_in_period = len(daily_counts) if daily_counts else 1
        daily_average = total_seconds / days_in_period if days_in_period > 0 else 0
        
        # Find most productive hours and days
        most_active_hour = max(hourly_counts.items(), key=lambda x: x[1])[0] if hourly_counts else None
        most_active_day = max(daily_counts.items(), key=lambda x: x[1])[0] if daily_counts else None
        
        # Calculate session stats
        session_durations = [(end - start) for start, end in sessions] if sessions else []
        avg_session_length = sum(session_durations) / len(session_durations) if session_durations else 0
        
        # Productivity insights
        productivity_score = min(100, (total_seconds / max(1, days_in_period)) / 36) if total_seconds > 0 else 0  # Based on 10h = 100%
        
        # Command efficiency (commands per minute)
        cmd_efficiency = (total_commands / (total_seconds / 60)) if total_seconds > 0 else 0
        
        # Peak vs quiet hours analysis
        if hourly_counts:
            peak_hours = [h for h, s in hourly_counts.items() if s >= max(hourly_counts.values()) * 0.7]
            quiet_hours = [h for h, s in hourly_counts.items() if s <= max(hourly_counts.values()) * 0.3]
        else:
            peak_hours, quiet_hours = [], []
        
        # Language diversity (how many different languages used)
        language_diversity = len([l for l in language_counts if language_counts[l] > 60])  # > 1 minute
        
        # Streak analysis (consecutive active days)
        if daily_counts:
            sorted_days = sorted(daily_counts.keys())
            current_streak = 1
            for i in range(len(sorted_days) - 1):
                if (sorted_days[i+1] - sorted_days[i]).days == 1:
                    current_streak += 1
                else:
                    break
        else:
            current_streak = 0
        
        # Format top items with percentages
        def format_top_items(counter, limit=10):
            items = []
            for name, seconds in counter.most_common(limit):
                percentage = (seconds / total_seconds * 100) if total_seconds > 0 else 0
                items.append({
                    'name': name,
                    'total_seconds': seconds,
                    'percent': percentage
                })
            return items
        
        return {
            "data": {
                "total_seconds": total_seconds,
                "total_commands": total_commands,
                "daily_average": daily_average,
                "session_count": len(sessions),
                "avg_session_length": avg_session_length,
                "first_activity": first_activity.isoformat() if first_activity else None,
                "last_activity": last_activity.isoformat() if last_activity else None,
                "most_active_hour": most_active_hour,
                "most_active_day": str(most_active_day) if most_active_day else None,
                "productivity_score": productivity_score,
                "cmd_efficiency": cmd_efficiency,
                "peak_hours": peak_hours,
                "quiet_hours": quiet_hours,
                "language_diversity": language_diversity,
                "current_streak": current_streak,
                "languages": format_top_items(language_counts),
                "projects": format_top_items(project_counts),
                "commands": [
                    {"name": cmd, "count": count, "percent": count/total_commands*100 if total_commands > 0 else 0}
                    for cmd, count in command_counts.most_common(10)
                ],
                "daily_breakdown": {
                    str(date): seconds for date, seconds in daily_counts.items()
                },
                "hourly_breakdown": dict(hourly_counts)
            }
        }


class StatsFormatter:
    """Format statistics for terminal display with colors and enhanced information"""
    
    @staticmethod
    def format_time(seconds: float) -> str:
        """Convert seconds to human readable time format"""
        if seconds < 60:
            return f"{int(seconds)}s"
        elif seconds < 3600:
            minutes = int(seconds // 60)
            remaining_seconds = int(seconds % 60)
            if remaining_seconds > 0:
                return f"{minutes}m {remaining_seconds}s"
            return f"{minutes}m"
        else:
            hours = int(seconds // 3600)
            minutes = int((seconds % 3600) // 60)
            if minutes > 0:
                return f"{hours}h {minutes}m"
            return f"{hours}h"
    
    @staticmethod
    def format_percentage_bar(percentage: float, width: int = 20) -> str:
        """Create a visual percentage bar"""
        filled = int(percentage / 100 * width)
        bar = "‚ñà" * filled + "‚ñë" * (width - filled)
        return f"{Colors.CYAN}{bar}{Colors.RESET}"
    
    @staticmethod
    def format_hour_display(hour: int) -> str:
        """Format hour in 12-hour format"""
        if hour == 0:
            return "12:00 AM"
        elif hour < 12:
            return f"{hour}:00 AM"
        elif hour == 12:
            return "12:00 PM"
        else:
            return f"{hour-12}:00 PM"
    
    @staticmethod
    def create_sparkline(data: List[float], width: int = 24) -> str:
        """Create a sparkline from data points"""
        if not data:
            return "‚ñë" * width
            
        # Normalize data to 0-7 range for spark characters
        min_val = min(data)
        max_val = max(data)
        if max_val == min_val:
            return "‚ñÑ" * width
            
        sparks = "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà"
        normalized = [(x - min_val) / (max_val - min_val) * 7 for x in data]
        
        # Resample to fit width
        step = len(normalized) / width
        sparkline = ""
        for i in range(width):
            idx = int(i * step)
            if idx < len(normalized):
                sparkline += sparks[int(normalized[idx])]
            else:
                sparkline += "‚ñë"
        return sparkline
    
    @staticmethod
    def get_productivity_emoji(score: float) -> str:
        """Get emoji based on productivity score"""
        if score >= 80:
            return "üöÄ"
        elif score >= 60:
            return "üí™"
        elif score >= 40:
            return "üìà"
        elif score >= 20:
            return "üå±"
        else:
            return "üí§"
    
    @staticmethod
    def format_stats(stats_data: Dict, title: str, use_colors: bool = True) -> str:
        """Format stats data for display with colors and enhanced information"""
        if not use_colors:
            Colors.disable()
            
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            return f"\n{Colors.RED}No terminal activity recorded{Colors.RESET}\n"
        
        data = stats_data['data']
        output = []
        
        # Header
        output.append(f"\n{Colors.BOLD}{Colors.BRIGHT_CYAN}{title}{Colors.RESET}")
        output.append(f"{Colors.GRAY}{'‚îÄ' * len(title)}{Colors.RESET}")
        
        # Overview Section
        output.append(f"\n{Colors.BOLD}{Colors.YELLOW}OVERVIEW{Colors.RESET}")
        
        if 'total_seconds' in data:
            total_time = StatsFormatter.format_time(data['total_seconds'])
            total_commands = data.get('total_commands', 0)
            output.append(f"{Colors.GREEN}Total Time:{Colors.RESET} {Colors.BOLD}{total_time}{Colors.RESET}")
            output.append(f"{Colors.GREEN}Commands Run:{Colors.RESET} {Colors.BOLD}{total_commands:,}{Colors.RESET}")
        
        if 'daily_average' in data and data['daily_average']:
            avg_time = StatsFormatter.format_time(data['daily_average'])
            output.append(f"{Colors.GREEN}Daily Average:{Colors.RESET} {Colors.BOLD}{avg_time}{Colors.RESET}")
        
        # Session Information
        if 'session_count' in data and data['session_count']:
            session_count = data['session_count']
            avg_session = StatsFormatter.format_time(data.get('avg_session_length', 0))
            output.append(f"{Colors.GREEN}Sessions:{Colors.RESET} {Colors.BOLD}{session_count}{Colors.RESET}")
            output.append(f"{Colors.GREEN}Avg Session Length:{Colors.RESET} {Colors.BOLD}{avg_session}{Colors.RESET}")
        
        # Activity Period
        if data.get('first_activity') and data.get('last_activity'):
            try:
                first = datetime.fromisoformat(data['first_activity']).strftime('%Y-%m-%d %H:%M')
                last = datetime.fromisoformat(data['last_activity']).strftime('%Y-%m-%d %H:%M')
                output.append(f"{Colors.GREEN}Active Period:{Colors.RESET} {Colors.DIM}{first} ‚Üí {last}{Colors.RESET}")
            except Exception as e:
                pass
        
        # Peak Activity & Insights
        if data.get('most_active_hour') is not None:
            peak_hour = StatsFormatter.format_hour_display(data['most_active_hour'])
            output.append(f"{Colors.GREEN}Most Active Hour:{Colors.RESET} {Colors.BOLD}{peak_hour}{Colors.RESET}")
        
        # Productivity Insights Section
        if 'productivity_score' in data:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}PRODUCTIVITY INSIGHTS{Colors.RESET}")
            
            # Productivity Score
            score = data.get('productivity_score', 0)
            emoji = StatsFormatter.get_productivity_emoji(score) if use_colors else ""
            score_color = Colors.BRIGHT_GREEN if score >= 70 else Colors.YELLOW if score >= 40 else Colors.RED
            output.append(f"{Colors.GREEN}Productivity Score:{Colors.RESET} {score_color}{emoji} {score:.1f}/100{Colors.RESET}")
            
            # Command Efficiency
            if 'cmd_efficiency' in data and data['cmd_efficiency'] > 0:
                efficiency = data['cmd_efficiency']
                output.append(f"{Colors.GREEN}Commands per Minute:{Colors.RESET} {Colors.BOLD}{efficiency:.1f}{Colors.RESET}")
            
            # Current Streak
            if data.get('current_streak', 0) > 0:
                streak = data['current_streak']
                streak_emoji = "üî•" if streak >= 7 else "‚≠ê" if streak >= 3 else "‚ú®"
                if not use_colors:
                    streak_emoji = ""
                output.append(f"{Colors.GREEN}Active Days Streak:{Colors.RESET} {Colors.BOLD}{streak_emoji} {streak} days{Colors.RESET}")
            
            # Language Diversity
            if data.get('language_diversity', 0) > 1:
                diversity = data['language_diversity']
                output.append(f"{Colors.GREEN}Technologies Used:{Colors.RESET} {Colors.BOLD}{diversity} different{Colors.RESET}")
            
            # Peak/Quiet Hours Analysis
            peak_hours = data.get('peak_hours', [])
            if peak_hours:
                formatted_peaks = [StatsFormatter.format_hour_display(h).split()[0] for h in sorted(peak_hours)[:3]]
                output.append(f"{Colors.GREEN}Peak Hours:{Colors.RESET} {Colors.DIM}{', '.join(formatted_peaks)}{Colors.RESET}")
        
        # Languages/Categories Section
        if 'languages' in data and data['languages']:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}LANGUAGES & TECHNOLOGIES{Colors.RESET}")
            for i, lang in enumerate(data['languages'][:10], 1):
                name = lang.get('name', 'Unknown')
                percent = lang.get('percent', 0)
                time_str = StatsFormatter.format_time(lang.get('total_seconds', 0))
                bar = StatsFormatter.format_percentage_bar(percent, 15)
                
                # Color coding based on rank
                if i == 1:
                    color = Colors.BRIGHT_GREEN
                elif i <= 3:
                    color = Colors.BRIGHT_BLUE
                else:
                    color = Colors.WHITE
                
                # Ensure consistent width for language names
                display_name = name[:18] + "..." if len(name) > 21 else name
                    
                output.append(f"{color}{i:2d}. {display_name:<21}{Colors.RESET} {bar} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({percent:5.1f}%){Colors.RESET}")
        
        # Commands Section
        if 'commands' in data and data['commands']:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}TOP COMMANDS{Colors.RESET}")
            for i, cmd in enumerate(data['commands'][:10], 1):
                name = cmd.get('name', 'unknown')
                count = cmd.get('count', 0)
                percent = cmd.get('percent', 0)
                bar = StatsFormatter.format_percentage_bar(percent, 15)
                
                if i == 1:
                    color = Colors.BRIGHT_GREEN
                elif i <= 3:
                    color = Colors.BRIGHT_BLUE
                else:
                    color = Colors.WHITE
                
                # Truncate very long command names and ensure consistent width
                display_name = name[:18] + "..." if len(name) > 21 else name
                    
                output.append(f"{color}{i:2d}. {display_name:<21}{Colors.RESET} {bar} {Colors.BOLD}{count:>4}{Colors.RESET} times {Colors.DIM}({percent:4.1f}%){Colors.RESET}")
        
        # Projects Section
        if 'projects' in data and data['projects'] and len(data['projects']) > 1:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}PROJECTS{Colors.RESET}")
            for i, project in enumerate(data['projects'][:6], 1):
                name = project.get('name', 'Unknown')
                if name == 'Unknown':
                    continue
                    
                percent = project.get('percent', 0)
                time_str = StatsFormatter.format_time(project.get('total_seconds', 0))
                bar = StatsFormatter.format_percentage_bar(percent, 15)
                
                if i == 1:
                    color = Colors.BRIGHT_GREEN
                elif i <= 3:
                    color = Colors.BRIGHT_BLUE
                else:
                    color = Colors.WHITE
                    
                # Truncate long project names with consistent width
                display_name = name[:18] + "..." if len(name) > 21 else name
                output.append(f"{color}{i:2d}. {display_name:<21}{Colors.RESET} {bar} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({percent:5.1f}%){Colors.RESET}")
        
        # Activity Timeline (last 7 days if available)
        if 'daily_breakdown' in data and data['daily_breakdown']:
            daily_data = data['daily_breakdown']
            if len(daily_data) > 1:
                output.append(f"\n{Colors.BOLD}{Colors.YELLOW}ACTIVITY TIMELINE{Colors.RESET}")
                
                # Hourly sparkline for today/recent period
                if 'hourly_breakdown' in data and data['hourly_breakdown']:
                    hourly_data = data['hourly_breakdown']
                    # Create 24-hour array
                    hourly_values = [hourly_data.get(h, 0) for h in range(24)]
                    sparkline = StatsFormatter.create_sparkline(hourly_values, 24)
                    output.append(f"{Colors.DIM}24h Pattern: {Colors.CYAN}{sparkline}{Colors.RESET}")
                    output.append(f"{Colors.DIM}             12a    6a    12p    6p    12a{Colors.RESET}\n")
                
                # Sort by date and take last 7 days
                sorted_days = sorted(daily_data.items())[-7:]
                max_seconds = max(daily_data.values()) if daily_data.values() else 1
                
                for date_str, seconds in sorted_days:
                    try:
                        date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                        day_name = date_obj.strftime('%a')
                        date_display = date_obj.strftime('%m/%d')
                        
                        time_str = StatsFormatter.format_time(seconds)
                        percent_of_max = (seconds / max_seconds) * 100
                        bar_length = int(percent_of_max / 100 * 20)
                        bar = "‚ñà" * bar_length + "‚ñë" * (20 - bar_length)
                        
                        # Smart color coding based on activity level
                        if seconds == max_seconds:
                            bar_color = Colors.BRIGHT_GREEN
                            day_indicator = "üî•" if use_colors else "*"
                        elif seconds > max_seconds * 0.7:
                            bar_color = Colors.GREEN
                            day_indicator = "üí™" if use_colors else "+"
                        elif seconds > max_seconds * 0.3:
                            bar_color = Colors.YELLOW
                            day_indicator = "üìà" if use_colors else "~"
                        elif seconds > 0:
                            bar_color = Colors.GRAY
                            day_indicator = "üí§" if use_colors else "-"
                        else:
                            bar_color = Colors.DIM
                            day_indicator = "  " if use_colors else " "
                            
                        # Add productivity indicator for the day
                        daily_productivity = min(100, (seconds / 36) * 10) if seconds > 0 else 0
                        productivity_display = f"{daily_productivity:3.0f}%" if seconds > 0 else "  0%"
                        
                        output.append(f"{day_indicator} {day_name} {date_display}  {bar_color}{bar}{Colors.RESET} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({productivity_display}){Colors.RESET}")
                    except:
                        continue
        
        return "\n".join(output) + "\n"
    
    @staticmethod
    def export_data(stats_data: Dict, format_type: str, period: str, filters: Optional[Dict] = None):
        """Export data in various formats"""
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            print("No data to export", file=sys.stderr)
            return
        
        data = stats_data['data']
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filter_suffix = ""
        
        if filters:
            filter_parts = []
            for k, v in filters.items():
                if v:
                    filter_parts.append(f"{k}_{v}")
            if filter_parts:
                filter_suffix = f"_{'_'.join(filter_parts)}"
        
        if format_type == "csv":
            import csv
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.csv"
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['Category', 'Name', 'Time_Seconds', 'Percentage'])
                
                for lang in data.get('languages', []):
                    writer.writerow(['Language', lang['name'], lang['total_seconds'], lang['percent']])
                
                for cmd in data.get('commands', []):
                    writer.writerow(['Command', cmd['name'], cmd.get('total_seconds', 0), cmd['percent']])
                
                for proj in data.get('projects', []):
                    writer.writerow(['Project', proj['name'], proj['total_seconds'], proj['percent']])
            
            print(f"Data exported to {filename}")
        
        elif format_type == "markdown":
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.md"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"# Terminal Activity Report - {period.replace('_', ' ').title()}\n\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if filters:
                    f.write("## Filters Applied\n\n")
                    for k, v in filters.items():
                        if v:
                            f.write(f"- {k.title()}: `{v}`\n")
                    f.write("\n")
                
                f.write("## Overview\n\n")
                f.write(f"- **Total Time:** {StatsFormatter.format_time(data.get('total_seconds', 0))}\n")
                f.write(f"- **Total Commands:** {data.get('total_commands', 0):,}\n")
                f.write(f"- **Daily Average:** {StatsFormatter.format_time(data.get('daily_average', 0))}\n")
                f.write(f"- **Productivity Score:** {data.get('productivity_score', 0):.1f}/100\n\n")
                
                if data.get('languages'):
                    f.write("## Top Languages\n\n")
                    f.write("| Rank | Language | Time | Percentage |\n")
                    f.write("|------|----------|------|------------|\n")
                    for i, lang in enumerate(data['languages'][:10], 1):
                        time_str = StatsFormatter.format_time(lang['total_seconds'])
                        f.write(f"| {i} | {lang['name']} | {time_str} | {lang['percent']:.1f}% |\n")
                    f.write("\n")
            
            print(f"Report exported to {filename}")
        
        elif format_type == "json":
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.json"
            with open(filename, 'w', encoding='utf-8') as f:
                export_data = {
                    'metadata': {
                        'period': period,
                        'generated': datetime.now().isoformat(),
                        'filters': filters or {}
                    },
                    'stats': stats_data
                }
                json.dump(export_data, f, indent=2)
            
            print(f"Data exported to {filename}")
    
    @staticmethod
    def format_summary(stats_data: Dict, title: str, use_colors: bool = True) -> str:
        """Format compact summary statistics"""
        if not use_colors:
            Colors.disable()
            
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            return f"\n{Colors.RED}No terminal activity recorded{Colors.RESET}\n"
        
        data = stats_data['data']
        output = []
        
        # Compact header
        output.append(f"{Colors.BOLD}{Colors.BRIGHT_CYAN}{title}{Colors.RESET}")
        
        # Key metrics in one line
        total_time = StatsFormatter.format_time(data.get('total_seconds', 0))
        total_commands = data.get('total_commands', 0)
        productivity = data.get('productivity_score', 0)
        sessions = data.get('session_count', 0)
        
        emoji = StatsFormatter.get_productivity_emoji(productivity) if use_colors else ""
        score_color = Colors.BRIGHT_GREEN if productivity >= 70 else Colors.YELLOW if productivity >= 40 else Colors.RED
        
        output.append(f"{Colors.GREEN}Time:{Colors.RESET} {Colors.BOLD}{total_time}{Colors.RESET} | "
                     f"{Colors.GREEN}Commands:{Colors.RESET} {Colors.BOLD}{total_commands}{Colors.RESET} | "
                     f"{Colors.GREEN}Sessions:{Colors.RESET} {Colors.BOLD}{sessions}{Colors.RESET} | "
                     f"{Colors.GREEN}Score:{Colors.RESET} {score_color}{emoji}{productivity:.0f}%{Colors.RESET}")
        
        # Top 3 languages/commands in compact format
        if data.get('languages'):
            top_langs = data['languages'][:3]
            lang_summary = " | ".join([f"{lang['name']} ({lang['percent']:.0f}%)" for lang in top_langs])
            output.append(f"{Colors.YELLOW}Top:{Colors.RESET} {lang_summary}")
        
        return "\n".join(output) + "\n"


def handle_ignore_commands(args, use_colors: bool):
    """Handle ignore pattern management commands"""
    try:
        # Import the ignore filter module  
        sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
        from ignore_filter import CommandIgnoreFilter
    except ImportError:
        error_color = Colors.RED if use_colors else ""
        reset_color = Colors.RESET if use_colors else ""
        print(f"{error_color}Error: Could not import ignore filter module{reset_color}", file=sys.stderr)
        sys.exit(1)
    
    ignore_filter = CommandIgnoreFilter()
    
    if args.ignore_action == "add":
        if ignore_filter.add_pattern(args.pattern):
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Added ignore pattern: {args.pattern}{reset_color}")
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}Pattern '{args.pattern}' already exists{reset_color}")
        
    elif args.ignore_action == "remove":
        if ignore_filter.remove_pattern(args.pattern):
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Removed ignore pattern: {args.pattern}{reset_color}")
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}Pattern not found: {args.pattern}{reset_color}")
            
    elif args.ignore_action == "list":
        patterns = ignore_filter.list_patterns()
        if patterns:
            header_color = Colors.CYAN if use_colors else ""
            pattern_color = Colors.WHITE if use_colors else ""
            negation_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            
            print(f"{header_color}Current ignore patterns:{reset_color}")
            for pattern in patterns:
                if pattern.startswith("!"):
                    print(f"  {negation_color}{pattern} (negation){reset_color}")
                else:
                    print(f"  {pattern_color}{pattern}{reset_color}")
            print(f"\n{Colors.DIM if use_colors else ''}Ignore file: {ignore_filter.get_ignore_file_path()}{reset_color}")
        else:
            info_color = Colors.BLUE if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{info_color}No ignore patterns configured{reset_color}")
            
    elif args.ignore_action == "test":
        test_command = getattr(args, 'test_command', None)
        if ignore_filter.should_ignore(test_command):
            warn_color = Colors.RED if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}IGNORE: '{test_command}' would be ignored{reset_color}")
        else:
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}TRACK: '{test_command}' would be tracked{reset_color}")
            
    elif args.ignore_action == "edit":
        ignore_file = ignore_filter.get_ignore_file_path()
        
        # Try to find a suitable editor
        editor = os.environ.get('EDITOR') or os.environ.get('VISUAL')
        if not editor:
            # Try common editors
            for cmd in ['nano', 'vim', 'vi', 'emacs', 'code']:
                try:
                    result = subprocess.run(['command', '-v', cmd], 
                                           stdout=subprocess.DEVNULL, 
                                           stderr=subprocess.DEVNULL)
                    if result.returncode == 0:
                        editor = cmd
                        break
                except (subprocess.SubprocessError, FileNotFoundError):
                    continue
        
        if editor:
            info_color = Colors.BLUE if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{info_color}Opening {ignore_file} in {editor}...{reset_color}")
            try:
                subprocess.run([editor, str(ignore_file)])
            except (subprocess.SubprocessError, FileNotFoundError) as e:
                error_color = Colors.RED if use_colors else ""
                print(f"{error_color}Error opening editor: {e}{reset_color}", file=sys.stderr)
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}No editor found. Please edit manually: {ignore_file}{reset_color}")
            
    elif args.ignore_action == "clear":
        if not args.yes:
            response = input("Are you sure you want to clear all ignore patterns? (y/N): ").strip().lower()
            if response not in ['y', 'yes']:
                print("Cancelled")
                return
        
        ignore_file = ignore_filter.get_ignore_file_path()
        try:
            if os.path.exists(ignore_file):
                os.remove(ignore_file)
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Cleared all ignore patterns{reset_color}")
        except Exception as e:
            error_color = Colors.RED if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{error_color}Error clearing patterns: {e}{reset_color}")
    
    else:
        # Show ignore help if no action specified
        error_color = Colors.RED if use_colors else ""
        reset_color = Colors.RESET if use_colors else ""
        print(f"{error_color}Please specify an action: add, remove, list, test, edit, or clear{reset_color}")
        print("Use 'wakatermctl ignore --help' for more information")


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="View your terminal activity statistics from local logs and manage ignore patterns",
        prog="wakatermctl",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Stats commands
  wakatermctl stats              # Show today's stats
  wakatermctl stats yesterday    # Show yesterday's stats  
  wakatermctl stats last_7_days  # Show last week's stats
  wakatermctl stats --no-color   # Show stats without colors
  wakatermctl stats --json       # Output raw JSON data
  
  # Ignore pattern management  
  wakatermctl ignore add "git status"    # Add pattern to ignore
  wakatermctl ignore add "debug_*"       # Add wildcard pattern
  wakatermctl ignore remove "ls"         # Remove pattern
  wakatermctl ignore list                # List all patterns
  wakatermctl ignore test "git status"   # Test if command would be ignored
  wakatermctl ignore edit               # Open ignore file in editor
        """
    )
    
    # Add global arguments
    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )
    
        # Create subparsers for stats and ignore commands
    subparsers = parser.add_subparsers(dest="subcommand", help="Available commands")
    
    # Stats subparser (default behavior)
    stats_parser = subparsers.add_parser(
        "stats", 
        help="Show terminal activity statistics (default command)",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Add arguments to stats parser
    stats_parser.add_argument(
        "period",
        nargs="?",
        default="today",
        choices=["today", "yesterday", "last_7_days", "last_30_days", "last_6_months", "last_year"],
        help="Time period for statistics (default: today)"
    )
    
    stats_parser.add_argument(
        "--json",
        action="store_true",
        help="Output raw JSON data instead of formatted display"
    )
    
    stats_parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )
    
    stats_parser.add_argument(
        "--log-dir",
        help="Directory containing wakaterm log files (default: ~/.local/share/wakaterm-logs)"
    )
    
    stats_parser.add_argument(
        "--debug",
        action="store_true",
        help="Show debug information"
    )
    
    stats_parser.add_argument(
        "--project",
        help="Filter by specific project name"
    )
    
    stats_parser.add_argument(
        "--language",
        help="Filter by specific language/technology"
    )
    
    stats_parser.add_argument(
        "--command",
        help="Filter by specific command pattern (supports wildcards)"
    )
    
    stats_parser.add_argument(
        "--min-time",
        type=int,
        help="Minimum seconds to include in analysis (default: 2)"
    )
    
    stats_parser.add_argument(
        "--summary",
        action="store_true",
        help="Show only summary statistics"
    )
    
    stats_parser.add_argument(
        "--export",
        choices=["csv", "json", "markdown"],
        help="Export data in specified format"
    )
    
    # Ignore patterns subparser
    ignore_parser = subparsers.add_parser("ignore", help="Manage command ignore patterns")
    ignore_subparsers = ignore_parser.add_subparsers(dest="ignore_action", help="Ignore pattern actions")
    
    # Add pattern
    add_parser = ignore_subparsers.add_parser("add", help="Add an ignore pattern")
    add_parser.add_argument("pattern", help="Pattern to add (supports wildcards like git*, debug_*, etc.)")
    
    # Remove pattern  
    remove_parser = ignore_subparsers.add_parser("remove", help="Remove an ignore pattern")
    remove_parser.add_argument("pattern", help="Pattern to remove")
    
    # List patterns
    list_parser = ignore_subparsers.add_parser("list", help="List all ignore patterns")
    
    # Test pattern
    test_parser = ignore_subparsers.add_parser("test", help="Test if a command would be ignored")
    test_parser.add_argument("test_command", help="Command to test")
    
    # Edit patterns file
    edit_parser = ignore_subparsers.add_parser("edit", help="Open ignore patterns file in editor")
    
    # Clear all patterns
    clear_parser = ignore_subparsers.add_parser("clear", help="Clear all ignore patterns")
    clear_parser.add_argument("--yes", action="store_true", help="Skip confirmation prompt")
    
    # Handle case where no arguments are provided - default to stats today
    if len(sys.argv) == 1:
        # Default to 'stats today' when no arguments provided
        sys.argv.extend(['stats', 'today'])
    
    # Parse arguments using the configured parser
    try:
        args = parser.parse_args()
    except SystemExit:
        # argparse calls sys.exit on error, let it handle help and errors
        return
    
    # If no command specified but we have args, default to stats
    if not hasattr(args, 'subcommand') or args.subcommand is None:
        args.subcommand = 'stats'
        if not hasattr(args, 'period'):
            args.period = 'today'
    

    
    # Disable colors if requested or if not in a terminal
    use_colors = not args.no_color and sys.stdout.isatty()
    
    try:
        # Handle ignore pattern management
        if args.subcommand == "ignore":
            handle_ignore_commands(args, use_colors)
            return
            
        # For stats commands, ensure we have all required attributes
        stats_attrs = ['log_dir', 'debug', 'project', 'language', 'min_time', 'summary', 'export', 'json', 'period']
        for attr in stats_attrs:
            if not hasattr(args, attr):
                if attr == 'debug':
                    setattr(args, attr, False)
                elif attr == 'period':
                    setattr(args, attr, 'today')
                else:
                    setattr(args, attr, None)
            
        # Initialize stats reader
        reader = LocalStatsReader(args.log_dir)
        
        # Show debug info if requested
        if args.debug:
            debug_color = "" if not use_colors else Colors.YELLOW
            reset_color = "" if not use_colors else Colors.RESET
            
            print(f"{debug_color}Debug Info:{reset_color}", file=sys.stderr)
            print(f"  Log directory: {reader.log_dir}", file=sys.stderr)
            print(f"  Directory exists: {reader.log_dir.exists()}", file=sys.stderr)
            print(f"  Colors enabled: {use_colors}", file=sys.stderr)
            
            if reader.log_dir.exists():
                log_files = list(reader.log_dir.glob("wakaterm-*.jsonl"))
                print(f"  Log files found: {len(log_files)}", file=sys.stderr)
                for log_file in sorted(log_files)[-5:]:  # Show last 5 files
                    print(f"    {log_file.name}", file=sys.stderr)
            print("", file=sys.stderr)
        
        # Prepare filters
        filters = {}
        if args.project:
            filters['project'] = args.project
        if args.language:
            filters['language'] = args.language
        if args.command:
            filters['command'] = args.command
        if args.min_time:
            filters['min_time'] = args.min_time
        
        # Get statistics
        stats = reader.get_stats_for_period(args.period, filters if filters else None)
        
        # Handle export formats
        if args.export:
            StatsFormatter.export_data(stats, args.export, args.period, filters)
            return
        
        if args.json:
            print(json.dumps(stats, indent=2))
            return
        
        # Format and display
        period_names = {
            "today": "Today's Terminal Activity",
            "yesterday": "Yesterday's Terminal Activity", 
            "last_7_days": "Last 7 Days Terminal Activity",
            "last_30_days": "Last 30 Days Terminal Activity",
            "last_6_months": "Last 6 Months Terminal Activity",
            "last_year": "Last Year Terminal Activity"
        }
        
        title = period_names.get(args.period, args.period.replace('_', ' ').title())
        
        # Handle summary mode
        if args.summary:
            formatted_stats = StatsFormatter.format_summary(stats, title or "Terminal Activity", use_colors)
        else:
            formatted_stats = StatsFormatter.format_stats(stats, title or "Terminal Activity", use_colors)
        
        print(formatted_stats)
        
    except KeyboardInterrupt:
        if use_colors:
            print(f"\n{Colors.CYAN}Goodbye!{Colors.RESET}")
        else:
            print("\nGoodbye!")
        sys.exit(0)
    except Exception as e:
        if getattr(args, 'debug', False):
            import traceback
            traceback.print_exc()
        else:
            error_color = Colors.RED if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{error_color}Error: {e}{reset_color}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
