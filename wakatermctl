#!/usr/bin/env python3
"""
WakaTermCtl - Terminal Stats Viewer for WakaTerm NG
A command-line tool to view your terminal activity statistics from local logs
"""
#why? cos API too complicated
# NOTE: Many parts of this script was generated by GitHub Copilot because manual labour was hard :pf:

import os
import sys
import json
import argparse
import subprocess
import shutil
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional
from collections import defaultdict, Counter


class ProgressIndicator:
    """Simple progress indicator for long-running operations"""
    
    def __init__(self, description: str = "Processing", enabled: bool = True):
        self.description = description
        self.enabled = enabled and sys.stdout.isatty()
        self.last_update = 0
        
    def update(self, current: int, total: int):
        """Update progress indicator"""
        if not self.enabled:
            return
            
        import time
        current_time = time.time()
        if current_time - self.last_update < 0.1:  # Update at most 10 times per second
            return
            
        self.last_update = current_time
        
        if total > 0:
            percentage = int((current / total) * 100)
            bar_length = 20
            filled = int((current / total) * bar_length)
            bar = "█" * filled + "░" * (bar_length - filled)
            
            print(f"\r{self.description}: [{bar}] {percentage}% ({current}/{total})", end="", flush=True)
    
    def finish(self, message: str = "Complete"):
        """Finish progress indicator"""
        if self.enabled:
            print(f"\r{message}{' ' * 50}")  # Clear the line


class Colors:
    """ANSI color codes for terminal output"""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'

    # Text colors
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    GRAY = '\033[90m'

    # Bright colors
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'
    BRIGHT_WHITE = '\033[97m'

    @staticmethod
    def disable():
        """Disable colors for non-terminal output"""
        for attr in dir(Colors):
            if not attr.startswith('_') and attr != 'disable':
                setattr(Colors, attr, '')


class LocalStatsReader:
    """Reads and analyzes terminal activity from local log files"""

    def __init__(self, log_dir: Optional[str] = None):
        self.log_dir = Path(log_dir or os.path.expanduser('~/.local/share/wakaterm-logs'))

    def _apply_filters(self, entries: List[Dict], filters: Dict) -> List[Dict]:
        """Apply advanced filters to log entries"""
        filtered = entries

        if filters.get('project'):
            project_filter = filters['project'].lower()
            filtered = [e for e in filtered if project_filter in e.get('project', '').lower()]

        if filters.get('language'):
            lang_filter = filters['language'].lower()
            filtered = [e for e in filtered if lang_filter in e.get('language', '').lower()]
        
        if filters.get('command'):
            import fnmatch
            cmd_pattern = filters['command']
            filtered = [e for e in filtered if fnmatch.fnmatch(e.get('base_command', ''), cmd_pattern)]
        
        if filters.get('min_time'):
            min_time = filters['min_time']
            filtered = [e for e in filtered if e.get('duration', 2.0) >= min_time]
        
        if filters.get('max_time'):
            max_time = filters['max_time']
            filtered = [e for e in filtered if e.get('duration', 2.0) <= max_time]
        
        if filters.get('start_date') or filters.get('end_date'):
            from datetime import datetime
            start_date = None
            end_date = None
            
            if filters.get('start_date'):
                try:
                    start_date = datetime.strptime(filters['start_date'], '%Y-%m-%d')
                except ValueError:
                    pass
            
            if filters.get('end_date'):
                try:
                    end_date = datetime.strptime(filters['end_date'], '%Y-%m-%d').replace(hour=23, minute=59, second=59)
                except ValueError:
                    pass
            
            if start_date or end_date:
                filtered_entries = []
                for e in filtered:
                    entry_time = datetime.fromtimestamp(e['timestamp'])
                    if start_date and entry_time < start_date:
                        continue
                    if end_date and entry_time > end_date:
                        continue
                    filtered_entries.append(e)
                filtered = filtered_entries
        
        if filters.get('hour_range'):
            hour_range = filters['hour_range']
            try:
                start_hour, end_hour = map(int, hour_range.split('-'))
                filtered = [e for e in filtered if start_hour <= datetime.fromtimestamp(e['timestamp']).hour <= end_hour]
            except (ValueError, TypeError):
                pass
        
        if filters.get('weekday'):
            weekday_map = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5, 'sun': 6}
            target_weekday = weekday_map.get(filters['weekday'].lower())
            if target_weekday is not None:
                filtered = [e for e in filtered if datetime.fromtimestamp(e['timestamp']).weekday() == target_weekday]
        
        if filters.get('command_type'):
            cmd_type = filters['command_type']
            type_mappings = {
                'file-ops': ['File Operations', 'Archive'],
                'text-proc': ['Text Processing'],
                'version-ctrl': ['Git', 'Subversion', 'Mercurial'],
                'build': ['Make', 'CMake', 'Ninja', 'Bazel'],
                'deploy': ['Docker', 'Kubernetes', 'Terraform', 'Ansible'],
                'admin': ['System Admin'],
                'network': ['Network', 'SSH', 'HTTP'],
                'package-mgr': ['Package Manager']
            }
            allowed_languages = type_mappings.get(cmd_type, [])
            filtered = [e for e in filtered if e.get('language', '') in allowed_languages]
        
        if filters.get('exclude_project'):
            exclude_project = filters['exclude_project'].lower()
            filtered = [e for e in filtered if exclude_project not in e.get('project', '').lower()]

        return filtered
    
    def _read_log_files(self, start_date: datetime, end_date: datetime) -> List[Dict]:
        """Read log entries from files within date range using streaming approach"""
        entries = []
        
        if not self.log_dir.exists():
            return entries
            
        # List of dates to check
        current_date = start_date.date()
        end_date_only = end_date.date()
        
        # Calculate total days for progress indicator
        total_days = (end_date_only - current_date).days + 1
        progress = ProgressIndicator("Reading logs", enabled=total_days > 7)  # Only show for longer periods
        day_count = 0
        
        while current_date <= end_date_only:
            log_file = self.log_dir / f"wakaterm-{current_date.strftime('%Y-%m-%d')}.jsonl"
            if log_file.exists():
                try:
                    # Use streaming approach to avoid loading entire file at once
                    with open(log_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            line = line.strip()
                            if line:
                                try:
                                    entry = json.loads(line)
                                    entry_time = datetime.fromtimestamp(entry['timestamp'])
                                    if start_date <= entry_time <= end_date:
                                        entries.append(entry)
                                except (json.JSONDecodeError, KeyError, ValueError):
                                    continue
                except Exception:
                    continue
            
            day_count += 1
            progress.update(day_count, total_days)
            current_date += timedelta(days=1)
        
        progress.finish("Log reading complete")
        return entries
    
    def get_stats_for_period(self, period: str, filters: Optional[Dict] = None) -> Dict:
        """Get stats for a specific period"""
        now = datetime.now()
        
        if period == "today":
            start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "yesterday":
            yesterday = now - timedelta(days=1)
            start_date = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = yesterday.replace(hour=23, minute=59, second=59, microsecond=999999)
        elif period == "last_7_days":
            start_date = (now - timedelta(days=7)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_30_days":
            start_date = (now - timedelta(days=30)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_6_months":
            start_date = (now - timedelta(days=180)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        elif period == "last_year":
            start_date = (now - timedelta(days=365)).replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        else:
            # Default to today
            start_date = now.replace(hour=0, minute=0, second=0, microsecond=0)
            end_date = now
        
        entries = self._read_log_files(start_date, end_date)
        
        # Apply filters if provided
        if filters:
            entries = self._apply_filters(entries, filters)
            
        return self._calculate_stats(entries, period)
    
    def _calculate_stats(self, entries: List[Dict], period: str) -> Dict:
        """Calculate statistics from log entries using optimized data structures"""
        if not entries:
            return {"data": None}
        
        # Use more efficient data structures
        from collections import Counter, defaultdict
        
        # Pre-allocate counters for better performance
        language_counts = Counter()
        project_counts = Counter()
        command_counts = Counter()
        daily_counts = defaultdict(float)
        hourly_counts = defaultdict(float)
        
        total_commands = len(entries)
        total_seconds = 0.0
        
        # Time tracking with single pass
        timestamps = []
        first_activity = None
        last_activity = None
        
        # Single pass through entries for efficiency
        for entry in entries:
            duration = entry.get('duration', 2.0)
            total_seconds += duration
            
            # Language, project, command counting
            language = entry.get('language', 'Unknown')
            project = entry.get('project', 'Unknown')
            base_command = entry.get('base_command', 'unknown')
            
            language_counts[language] += duration
            project_counts[project] += duration
            command_counts[base_command] += 1
            
            # Time-based analysis
            timestamp = entry['timestamp']
            timestamps.append(timestamp)
            
            entry_datetime = datetime.fromtimestamp(timestamp)
            entry_date = entry_datetime.date()
            entry_hour = entry_datetime.hour
            
            daily_counts[entry_date] += duration
            hourly_counts[entry_hour] += duration
        
        # Calculate time bounds
        if timestamps:
            timestamps.sort()  # Only sort once
            first_activity = datetime.fromtimestamp(timestamps[0])
            last_activity = datetime.fromtimestamp(timestamps[-1])
        
        # Session tracking (gaps > 15 minutes indicate new session)
        sessions = []
        if timestamps:
            session_start = timestamps[0]
            
            for i in range(1, len(timestamps)):
                if timestamps[i] - timestamps[i-1] > 900:  # 15 minutes gap
                    sessions.append((session_start, timestamps[i-1]))
                    session_start = timestamps[i]
            sessions.append((session_start, timestamps[-1]))
        
        # Calculate various metrics
        days_in_period = len(daily_counts) if daily_counts else 1
        daily_average = total_seconds / days_in_period if days_in_period > 0 else 0
        
        # Find most active hour and day
        most_active_hour = max(hourly_counts.items(), key=lambda x: x[1])[0] if hourly_counts else None
        most_active_day = max(daily_counts.items(), key=lambda x: x[1])[0] if daily_counts else None
        
        # Session stats
        session_durations = [(end - start) for start, end in sessions] if sessions else []
        avg_session_length = sum(session_durations) / len(session_durations) if session_durations else 0
        
        # Productivity and efficiency metrics
        productivity_score = min(100, (total_seconds / max(1, days_in_period)) / 36) if total_seconds > 0 else 0
        cmd_efficiency = (total_commands / (total_seconds / 60)) if total_seconds > 0 else 0
        
        # Peak/quiet hours analysis
        if hourly_counts:
            sorted_hours = sorted(hourly_counts.items(), key=lambda x: x[1], reverse=True)
            peak_hours = [h for h, s in sorted_hours[:3] if s >= sorted_hours[0][1] * 0.7]
            quiet_hours = [h for h, s in sorted_hours[-3:] if s <= sorted_hours[0][1] * 0.3]
        else:
            peak_hours, quiet_hours = [], []
        
        # Language diversity
        language_diversity = len([l for l in language_counts if language_counts[l] > 60])
        
        # Streak analysis
        if daily_counts:
            sorted_days = sorted(daily_counts.keys())
            current_streak = 1
            for i in range(len(sorted_days) - 1):
                if (sorted_days[i+1] - sorted_days[i]).days == 1:
                    current_streak += 1
                else:
                    break
        else:
            current_streak = 0
        
        # Optimized top items formatting
        def format_top_items(counter, limit=10, is_duration=True):
            if is_duration:
                # For duration-based counters
                items = []
                for name, seconds in counter.most_common(limit):
                    percentage = (seconds / total_seconds * 100) if total_seconds > 0 else 0
                    items.append({
                        'name': name,
                        'total_seconds': seconds,
                        'percent': percentage
                    })
                return items
            else:
                # For count-based counters
                items = []
                for name, count in counter.most_common(limit):
                    percentage = count / total_commands * 100 if total_commands > 0 else 0
                    items.append({
                        'name': name,
                        'count': count,
                        'percent': percentage
                    })
                return items
        
        return {
            "data": {
                "total_seconds": total_seconds,
                "total_commands": total_commands,
                "daily_average": daily_average,
                "session_count": len(sessions),
                "avg_session_length": avg_session_length,
                "first_activity": first_activity.isoformat() if first_activity else None,
                "last_activity": last_activity.isoformat() if last_activity else None,
                "most_active_hour": most_active_hour,
                "most_active_day": str(most_active_day) if most_active_day else None,
                "productivity_score": productivity_score,
                "cmd_efficiency": cmd_efficiency,
                "peak_hours": peak_hours,
                "quiet_hours": quiet_hours,
                "language_diversity": language_diversity,
                "current_streak": current_streak,
                "languages": format_top_items(language_counts, is_duration=True),
                "projects": format_top_items(project_counts, is_duration=True),
                "commands": format_top_items(command_counts, limit=10, is_duration=False),
                "daily_breakdown": {
                    str(date): seconds for date, seconds in daily_counts.items()
                },
                "hourly_breakdown": dict(hourly_counts)
            }
        }


class StatsFormatter:
    """Format statistics for terminal display with colors and enhanced information"""
    
    @staticmethod
    def format_time(seconds: float) -> str:
        """Convert seconds to human readable time format"""
        if seconds < 60:
            return f"{int(seconds)}s"
        elif seconds < 3600:
            minutes = int(seconds // 60)
            remaining_seconds = int(seconds % 60)
            if remaining_seconds > 0:
                return f"{minutes}m {remaining_seconds}s"
            return f"{minutes}m"
        else:
            hours = int(seconds // 3600)
            minutes = int((seconds % 3600) // 60)
            if minutes > 0:
                return f"{hours}h {minutes}m"
            return f"{hours}h"
    
    @staticmethod
    def format_percentage_bar(percentage: float, width: int = 20) -> str:
        """Create a visual percentage bar"""
        filled = int(percentage / 100 * width)
        bar = "█" * filled + "░" * (width - filled)
        return f"{Colors.CYAN}{bar}{Colors.RESET}"
    
    @staticmethod
    def format_hour_display(hour: int) -> str:
        """Format hour in 12-hour format"""
        if hour == 0:
            return "12:00 AM"
        elif hour < 12:
            return f"{hour}:00 AM"
        elif hour == 12:
            return "12:00 PM"
        else:
            return f"{hour-12}:00 PM"
    
    @staticmethod
    def create_sparkline(data: List[float], width: int = 24) -> str:
        """Create a sparkline from data points"""
        if not data:
            return "░" * width
            
        # Normalize data to 0-7 range for spark characters
        min_val = min(data)
        max_val = max(data)
        if max_val == min_val:
            return "▄" * width
            
        sparks = "▁▂▃▄▅▆▇█"
        normalized = [(x - min_val) / (max_val - min_val) * 7 for x in data]
        
        # Resample to fit width
        step = len(normalized) / width
        sparkline = ""
        for i in range(width):
            idx = int(i * step)
            if idx < len(normalized):
                sparkline += sparks[int(normalized[idx])]
            else:
                sparkline += "░"
        return sparkline
    
    @staticmethod
    def get_productivity_emoji(score: float) -> str:
        """Get emoji based on productivity score"""
        if score >= 80:
            return "🚀"
        elif score >= 60:
            return "💪"
        elif score >= 40:
            return "📈"
        elif score >= 20:
            return "🌱"
        else:
            return "💤"
    
    @staticmethod
    def format_stats(stats_data: Dict, title: str, use_colors: bool = True) -> str:
        """Format stats data for display with enhanced layout and readability"""
        if not use_colors:
            Colors.disable()
            
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            return f"\n{Colors.RED}No terminal activity recorded{Colors.RESET}\n"
        
        data = stats_data['data']
        output = []
        
        # Enhanced header with rounded corners and single layer
        title_width = len(title) + 4  # Add padding
        top_border = f"╭{'─' * (title_width - 2)}╮"
        bottom_border = f"╰{'─' * (title_width - 2)}╯"
        
        output.append(f"\n{Colors.BOLD}{Colors.BRIGHT_CYAN}{top_border}{Colors.RESET}")
        output.append(f"{Colors.BOLD}{Colors.BRIGHT_CYAN}│{Colors.RESET}{Colors.BOLD}{Colors.BRIGHT_WHITE} {title} {Colors.RESET}{Colors.BOLD}{Colors.BRIGHT_CYAN}│{Colors.RESET}")
        output.append(f"{Colors.BOLD}{Colors.BRIGHT_CYAN}{bottom_border}{Colors.RESET}\n")
        
        # Quick summary bar
        if 'total_seconds' in data and 'total_commands' in data:
            total_time = StatsFormatter.format_time(data['total_seconds'])
            total_commands = data.get('total_commands', 0)
            summary = f"Total: {total_time} • {total_commands:,} commands"
            output.append(f"{Colors.DIM}┌─ {summary} {'─' * (max(0, 55 - len(summary)))}─┐{Colors.RESET}")
        
        # Overview Section with better organization
        output.append(f"{Colors.BOLD}{Colors.YELLOW}📊 OVERVIEW{Colors.RESET}")
        output.append(f"{Colors.DIM}{'─' * 20}{Colors.RESET}")
        
        overview_items = []
        if 'total_seconds' in data:
            overview_items.append(f"{Colors.GREEN}Total Time:{Colors.RESET} {Colors.BOLD}{StatsFormatter.format_time(data['total_seconds'])}{Colors.RESET}")
        
        if 'total_commands' in data:
            overview_items.append(f"{Colors.GREEN}Commands:{Colors.RESET} {Colors.BOLD}{data['total_commands']:,}{Colors.RESET}")
        
        if 'daily_average' in data and data['daily_average']:
            overview_items.append(f"{Colors.GREEN}Daily Avg:{Colors.RESET} {Colors.BOLD}{StatsFormatter.format_time(data['daily_average'])}{Colors.RESET}")
        
        if 'session_count' in data and data['session_count']:
            overview_items.append(f"{Colors.GREEN}Sessions:{Colors.RESET} {Colors.BOLD}{data['session_count']}{Colors.RESET}")
        
        # Format overview in two columns for better space usage
        for i in range(0, len(overview_items), 2):
            left = overview_items[i]
            right = overview_items[i+1] if i+1 < len(overview_items) else ""
            if right:
                output.append(f"{left:<35} {right}")
            else:
                output.append(left)
        
        # Activity Period
        if data.get('first_activity') and data.get('last_activity'):
            try:
                first = datetime.fromisoformat(data['first_activity']).strftime('%Y-%m-%d %H:%M')
                last = datetime.fromisoformat(data['last_activity']).strftime('%Y-%m-%d %H:%M')
                output.append(f"{Colors.GREEN}Period:{Colors.RESET} {Colors.DIM}{first} → {last}{Colors.RESET}")
            except Exception as e:
                pass
        
        output.append("")  # Spacing
        
        # Peak Activity & Insights
        if data.get('most_active_hour') is not None:
            peak_hour = StatsFormatter.format_hour_display(data['most_active_hour'])
            output.append(f"{Colors.GREEN}Most Active Hour:{Colors.RESET} {Colors.BOLD}{peak_hour}{Colors.RESET}")
        
        # Productivity Insights Section with better layout
        if 'productivity_score' in data:
            output.append(f"{Colors.BOLD}{Colors.YELLOW}🚀 PRODUCTIVITY INSIGHTS{Colors.RESET}")
            output.append(f"{Colors.DIM}{'─' * 25}{Colors.RESET}")
            
            # Productivity Score with visual indicator
            score = data.get('productivity_score', 0)
            emoji = StatsFormatter.get_productivity_emoji(score) if use_colors else ""
            score_color = Colors.BRIGHT_GREEN if score >= 70 else Colors.YELLOW if score >= 40 else Colors.RED
            
            score_bar = StatsFormatter.format_percentage_bar(score, 15)
            output.append(f"{Colors.GREEN}Score:{Colors.RESET} {score_color}{emoji} {score:.1f}/100{Colors.RESET} {score_bar}")
            
            # Command Efficiency
            if 'cmd_efficiency' in data and data['cmd_efficiency'] > 0:
                efficiency = data['cmd_efficiency']
                output.append(f"{Colors.GREEN}Commands/min:{Colors.RESET} {Colors.BOLD}{efficiency:.1f}{Colors.RESET}")
            
            # Current Streak
            if data.get('current_streak', 0) > 0:
                streak = data['current_streak']
                streak_emoji = "🔥" if streak >= 7 else "⭐" if streak >= 3 else "✨"
                if not use_colors:
                    streak_emoji = ""
                output.append(f"{Colors.GREEN}Active Streak:{Colors.RESET} {Colors.BOLD}{streak_emoji} {streak} days{Colors.RESET}")
            
            # Language Diversity
            if data.get('language_diversity', 0) > 1:
                diversity = data['language_diversity']
                output.append(f"{Colors.GREEN}Technologies:{Colors.RESET} {Colors.BOLD}{diversity} different{Colors.RESET}")
            
            # Peak/Quiet Hours Analysis
            peak_hours = data.get('peak_hours', [])
            if peak_hours:
                formatted_peaks = [StatsFormatter.format_hour_display(h).split()[0] for h in sorted(peak_hours)[:3]]
                output.append(f"{Colors.GREEN}Peak Hours:{Colors.RESET} {Colors.DIM}{', '.join(formatted_peaks)}{Colors.RESET}")
        
        output.append("")  # Spacing
        
        # Languages/Categories Section with improved layout
        if 'languages' in data and data['languages']:
            output.append(f"{Colors.BOLD}{Colors.YELLOW}💻 LANGUAGES & TECHNOLOGIES{Colors.RESET}")
            output.append(f"{Colors.DIM}{'─' * 28}{Colors.RESET}")
            
            for i, lang in enumerate(data['languages'][:10], 1):
                name = lang.get('name', 'Unknown')
                percent = lang.get('percent', 0)
                time_str = StatsFormatter.format_time(lang.get('total_seconds', 0))
                bar = StatsFormatter.format_percentage_bar(percent, 12)
                
                # Color coding based on rank
                if i == 1:
                    color = Colors.BRIGHT_GREEN
                    rank_icon = "🥇"
                elif i == 2:
                    color = Colors.BRIGHT_BLUE
                    rank_icon = "🥈"
                elif i == 3:
                    color = Colors.YELLOW
                    rank_icon = "🥉"
                else:
                    color = Colors.WHITE
                    rank_icon = f"{i:2d}"
                
                # Ensure consistent width for language names
                display_name = name[:16] + "..." if len(name) > 19 else name
                    
                output.append(f"{color}{rank_icon}. {display_name:<19}{Colors.RESET} {bar} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({percent:5.1f}%){Colors.RESET}")
        
        # Commands Section with better formatting
        if 'commands' in data and data['commands']:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}⌨️  TOP COMMANDS{Colors.RESET}")
            output.append(f"{Colors.DIM}{'─' * 15}{Colors.RESET}")
            
            for i, cmd in enumerate(data['commands'][:10], 1):
                name = cmd.get('name', 'unknown')
                count = cmd.get('count', 0)
                percent = cmd.get('percent', 0)
                bar = StatsFormatter.format_percentage_bar(percent, 12)
                
                if i <= 3:
                    color = Colors.BRIGHT_GREEN if i == 1 else Colors.BRIGHT_BLUE if i == 2 else Colors.YELLOW
                else:
                    color = Colors.WHITE
                
                # Truncate very long command names
                display_name = name[:16] + "..." if len(name) > 19 else name
                    
                output.append(f"{color}{i:2d}. {display_name:<19}{Colors.RESET} {bar} {Colors.BOLD}{count:>4}{Colors.RESET} times {Colors.DIM}({percent:4.1f}%){Colors.RESET}")
        
        # Projects Section
        if 'projects' in data and data['projects'] and len(data['projects']) > 1:
            output.append(f"\n{Colors.BOLD}{Colors.YELLOW}📁 PROJECTS{Colors.RESET}")
            output.append(f"{Colors.DIM}{'─' * 10}{Colors.RESET}")
            
            for i, project in enumerate(data['projects'][:6], 1):
                name = project.get('name', 'Unknown')
                if name == 'Unknown':
                    continue
                    
                percent = project.get('percent', 0)
                time_str = StatsFormatter.format_time(project.get('total_seconds', 0))
                bar = StatsFormatter.format_percentage_bar(percent, 12)
                
                if i <= 3:
                    color = Colors.BRIGHT_GREEN if i == 1 else Colors.BRIGHT_BLUE if i == 2 else Colors.YELLOW
                else:
                    color = Colors.WHITE
                    
                # Truncate long project names
                display_name = name[:16] + "..." if len(name) > 19 else name
                output.append(f"{color}{i:2d}. {display_name:<19}{Colors.RESET} {bar} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({percent:5.1f}%){Colors.RESET}")
        
        output.append("")  # Final spacing
        
        # Activity Timeline (last 7 days if available) with improved layout
        if 'daily_breakdown' in data and data['daily_breakdown']:
            daily_data = data['daily_breakdown']
            if len(daily_data) > 1:
                output.append(f"{Colors.BOLD}{Colors.YELLOW}📈 ACTIVITY TIMELINE{Colors.RESET}")
                output.append(f"{Colors.DIM}{'─' * 20}{Colors.RESET}")
                
                # Hourly sparkline for today/recent period
                if 'hourly_breakdown' in data and data['hourly_breakdown']:
                    hourly_data = data['hourly_breakdown']
                    # Create 24-hour array
                    hourly_values = [hourly_data.get(h, 0) for h in range(24)]
                    sparkline = StatsFormatter.create_sparkline(hourly_values, 24)
                    output.append(f"{Colors.DIM}24h Pattern: {Colors.CYAN}{sparkline}{Colors.RESET}")
                    output.append(f"{Colors.DIM}             12a    6a    12p    6p    12a{Colors.RESET}")
                    output.append("")
                
                # Sort by date and take last 7 days
                sorted_days = sorted(daily_data.items())[-7:]
                max_seconds = max(daily_data.values()) if daily_data.values() else 1
                
                for date_str, seconds in sorted_days:
                    try:
                        date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                        day_name = date_obj.strftime('%a')
                        date_display = date_obj.strftime('%m/%d')
                        
                        time_str = StatsFormatter.format_time(seconds)
                        percent_of_max = (seconds / max_seconds) * 100
                        bar_length = int(percent_of_max / 100 * 15)
                        bar = "█" * bar_length + "░" * (15 - bar_length)
                        
                        # Smart color coding based on activity level
                        if seconds == max_seconds:
                            bar_color = Colors.BRIGHT_GREEN
                            day_indicator = "🔥" if use_colors else "*"
                        elif seconds > max_seconds * 0.7:
                            bar_color = Colors.GREEN
                            day_indicator = "💪" if use_colors else "+"
                        elif seconds > max_seconds * 0.3:
                            bar_color = Colors.YELLOW
                            day_indicator = "📈" if use_colors else "~"
                        elif seconds > 0:
                            bar_color = Colors.GRAY
                            day_indicator = "💤" if use_colors else "-"
                        else:
                            bar_color = Colors.DIM
                            day_indicator = "  " if use_colors else " "
                            
                        # Add productivity indicator for the day
                        daily_productivity = min(100, (seconds / 36) * 10) if seconds > 0 else 0
                        productivity_display = f"{daily_productivity:3.0f}%" if seconds > 0 else "  0%"
                        
                        output.append(f"{day_indicator} {Colors.BOLD}{day_name} {date_display}{Colors.RESET}  {bar_color}{bar}{Colors.RESET} {Colors.BOLD}{time_str:>8}{Colors.RESET} {Colors.DIM}({productivity_display}){Colors.RESET}")
                    except:
                        continue
        
        # Footer
        output.append(f"{Colors.DIM}{'─' * 60}{Colors.RESET}")
        return "\n".join(output) + "\n"
    
    @staticmethod
    def format_summary(stats_data: Dict, title: str, use_colors: bool = True) -> str:
        """Format a concise summary of stats data"""
        if not use_colors:
            Colors.disable()
            
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            return f"\n{Colors.RED}No terminal activity recorded{Colors.RESET}\n"
        
        data = stats_data['data']
        output = []
        
        # Compact header
        output.append(f"{Colors.BOLD}{Colors.BRIGHT_CYAN}{title}{Colors.RESET}")
        output.append(f"{Colors.DIM}{'─' * len(title)}{Colors.RESET}")
        
        # Key metrics in a compact format
        metrics = []
        if 'total_seconds' in data:
            metrics.append(f"Time: {StatsFormatter.format_time(data['total_seconds'])}")
        if 'total_commands' in data:
            metrics.append(f"Commands: {data['total_commands']:,}")
        if 'daily_average' in data and data['daily_average']:
            metrics.append(f"Daily Avg: {StatsFormatter.format_time(data['daily_average'])}")
        if 'productivity_score' in data:
            score = data['productivity_score']
            emoji = StatsFormatter.get_productivity_emoji(score) if use_colors else ""
            metrics.append(f"Score: {emoji}{score:.0f}%")
        
        output.append(" • ".join(metrics))
        
        # Top items summary
        if 'languages' in data and data['languages']:
            top_lang = data['languages'][0]
            output.append(f"Top Language: {top_lang['name']} ({StatsFormatter.format_time(top_lang['total_seconds'])})")
        
        if 'projects' in data and data['projects'] and len(data['projects']) > 1:
            top_proj = data['projects'][0]
            output.append(f"Top Project: {top_proj['name']} ({StatsFormatter.format_time(top_proj['total_seconds'])})")
        
        if 'commands' in data and data['commands']:
            top_cmd = data['commands'][0]
            output.append(f"Top Command: {top_cmd['name']} ({top_cmd['count']} times)")
        
        return "\n".join(output) + "\n"
    
    @staticmethod
    def export_data(stats_data: Dict, format_type: str, period: str, filters: Optional[Dict] = None):
        """Export data in various formats"""
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            print("No data to export", file=sys.stderr)
            return
        
        data = stats_data['data']
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filter_suffix = ""
        
        if filters:
            filter_parts = []
            for k, v in filters.items():
                if v:
                    filter_parts.append(f"{k}_{v}")
            if filter_parts:
                filter_suffix = f"_{'_'.join(filter_parts)}"
        
        if format_type == "csv":
            import csv
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.csv"
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['Category', 'Name', 'Time_Seconds', 'Percentage'])
                
                for lang in data.get('languages', []):
                    writer.writerow(['Language', lang['name'], lang['total_seconds'], lang['percent']])
                
                for cmd in data.get('commands', []):
                    writer.writerow(['Command', cmd['name'], cmd.get('total_seconds', 0), cmd['percent']])
                
                for proj in data.get('projects', []):
                    writer.writerow(['Project', proj['name'], proj['total_seconds'], proj['percent']])
            
            print(f"Data exported to {filename}")
        
        elif format_type == "markdown":
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.md"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"# Terminal Activity Report - {period.replace('_', ' ').title()}\n\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if filters:
                    f.write("## Filters Applied\n\n")
                    for k, v in filters.items():
                        if v:
                            f.write(f"- {k.title()}: `{v}`\n")
                    f.write("\n")
                
                f.write("## Overview\n\n")
                f.write(f"- **Total Time:** {StatsFormatter.format_time(data.get('total_seconds', 0))}\n")
                f.write(f"- **Total Commands:** {data.get('total_commands', 0):,}\n")
                f.write(f"- **Daily Average:** {StatsFormatter.format_time(data.get('daily_average', 0))}\n")
                f.write(f"- **Productivity Score:** {data.get('productivity_score', 0):.1f}/100\n\n")
                
                if data.get('languages'):
                    f.write("## Top Languages\n\n")
                    f.write("| Rank | Language | Time | Percentage |\n")
                    f.write("|------|----------|------|------------|\n")
                    for i, lang in enumerate(data['languages'][:10], 1):
                        time_str = StatsFormatter.format_time(lang['total_seconds'])
                        f.write(f"| {i} | {lang['name']} | {time_str} | {lang['percent']:.1f}% |\n")
                    f.write("\n")
            
            print(f"Report exported to {filename}")
        
        elif format_type == "json":
            filename = f"wakaterm_{period}{filter_suffix}_{timestamp}.json"
            with open(filename, 'w', encoding='utf-8') as f:
                export_data = {
                    'metadata': {
                        'period': period,
                        'generated': datetime.now().isoformat(),
                        'filters': filters or {}
                    },
                    'stats': stats_data
                }
                json.dump(export_data, f, indent=2)
            
            print(f"Data exported to {filename}")
    
    @staticmethod
    def format_summary(stats_data: Dict, title: str, use_colors: bool = True) -> str:
        """Format compact summary statistics"""
        if not use_colors:
            Colors.disable()
            
        if not stats_data or 'data' not in stats_data or not stats_data['data']:
            return f"\n{Colors.RED}No terminal activity recorded{Colors.RESET}\n"
        
        data = stats_data['data']
        output = []
        
        # Compact header
        output.append(f"{Colors.BOLD}{Colors.BRIGHT_CYAN}{title}{Colors.RESET}")
        
        # Key metrics in one line
        total_time = StatsFormatter.format_time(data.get('total_seconds', 0))
        total_commands = data.get('total_commands', 0)
        productivity = data.get('productivity_score', 0)
        sessions = data.get('session_count', 0)
        
        emoji = StatsFormatter.get_productivity_emoji(productivity) if use_colors else ""
        score_color = Colors.BRIGHT_GREEN if productivity >= 70 else Colors.YELLOW if productivity >= 40 else Colors.RED
        
        output.append(f"{Colors.GREEN}Time:{Colors.RESET} {Colors.BOLD}{total_time}{Colors.RESET} | "
                     f"{Colors.GREEN}Commands:{Colors.RESET} {Colors.BOLD}{total_commands}{Colors.RESET} | "
                     f"{Colors.GREEN}Sessions:{Colors.RESET} {Colors.BOLD}{sessions}{Colors.RESET} | "
                     f"{Colors.GREEN}Score:{Colors.RESET} {score_color}{emoji}{productivity:.0f}%{Colors.RESET}")
        
        # Top 3 languages/commands in compact format
        if data.get('languages'):
            top_langs = data['languages'][:3]
            lang_summary = " | ".join([f"{lang['name']} ({lang['percent']:.0f}%)" for lang in top_langs])
            output.append(f"{Colors.YELLOW}Top:{Colors.RESET} {lang_summary}")
        
        return "\n".join(output) + "\n"


def handle_ignore_commands(args, use_colors: bool):
    """Handle ignore pattern management commands"""
    try:
        # Import the ignore filter module  
        sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
        from ignore_filter import CommandIgnoreFilter
    except ImportError:
        error_color = Colors.RED if use_colors else ""
        reset_color = Colors.RESET if use_colors else ""
        print(f"{error_color}Error: Could not import ignore filter module{reset_color}", file=sys.stderr)
        sys.exit(1)
    
    ignore_filter = CommandIgnoreFilter()
    
    if args.ignore_action == "add":
        if ignore_filter.add_pattern(args.pattern):
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Added ignore pattern: {args.pattern}{reset_color}")
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}Pattern '{args.pattern}' already exists{reset_color}")
        
    elif args.ignore_action == "remove":
        if ignore_filter.remove_pattern(args.pattern):
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Removed ignore pattern: {args.pattern}{reset_color}")
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}Pattern not found: {args.pattern}{reset_color}")
            
    elif args.ignore_action == "list":
        patterns = ignore_filter.list_patterns()
        if patterns:
            header_color = Colors.CYAN if use_colors else ""
            pattern_color = Colors.WHITE if use_colors else ""
            negation_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            
            print(f"{header_color}Current ignore patterns:{reset_color}")
            for pattern in patterns:
                if pattern.startswith("!"):
                    print(f"  {negation_color}{pattern} (negation){reset_color}")
                else:
                    print(f"  {pattern_color}{pattern}{reset_color}")
            print(f"\n{Colors.DIM if use_colors else ''}Ignore file: {ignore_filter.get_ignore_file_path()}{reset_color}")
        else:
            info_color = Colors.BLUE if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{info_color}No ignore patterns configured{reset_color}")
            
    elif args.ignore_action == "test":
        test_command = getattr(args, 'test_command', None)
        if ignore_filter.should_ignore(test_command):
            warn_color = Colors.RED if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}IGNORE: '{test_command}' would be ignored{reset_color}")
        else:
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}TRACK: '{test_command}' would be tracked{reset_color}")
            
    elif args.ignore_action == "edit":
        ignore_file = ignore_filter.get_ignore_file_path()
        
        # Try to find a suitable editor
        editor = os.environ.get('EDITOR') or os.environ.get('VISUAL')
        if not editor:
            # Try common editors
            for cmd in ['nano', 'vim', 'vi', 'emacs', 'code']:
                if shutil.which(cmd) is not None:
                    editor = cmd
                    break
        
        if editor:
            info_color = Colors.BLUE if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{info_color}Opening {ignore_file} in {editor}...{reset_color}")
            subprocess.run([editor, ignore_file])
        else:
            warn_color = Colors.YELLOW if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{warn_color}No editor found. Please edit manually: {ignore_file}{reset_color}")
            
    elif args.ignore_action == "clear":
        if not args.yes:
            response = input("Are you sure you want to clear all ignore patterns? (y/N): ").strip().lower()
            if response not in ['y', 'yes']:
                print("Cancelled")
                return
        
        ignore_file = ignore_filter.get_ignore_file_path()
        try:
            if os.path.exists(ignore_file):
                os.remove(ignore_file)
            success_color = Colors.GREEN if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{success_color}Cleared all ignore patterns{reset_color}")
        except Exception as e:
            error_color = Colors.RED if use_colors else ""
            reset_color = Colors.RESET if use_colors else ""
            print(f"{error_color}Error clearing patterns: {e}{reset_color}")
    
    else:
        # Show ignore help if no action specified
        error_color = Colors.RED if use_colors else ""
        reset_color = Colors.RESET if use_colors else ""
        print(f"{error_color}Please specify an action: add, remove, list, test, edit, or clear{reset_color}")
        print("Use 'wakatermctl ignore --help' for more information")


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="View your terminal activity statistics from local logs and manage ignore patterns",
        prog="wakatermctl",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Stats commands
  wakatermctl stats                           # Show today's stats
  wakatermctl stats yesterday                 # Show yesterday's stats  
  wakatermctl stats last_7_days               # Show last week's stats
  wakatermctl stats --no-color                # Show stats without colors
  wakatermctl stats --json                    # Output raw JSON data
  wakatermctl stats --project "myproject"     # Filter by project
  wakatermctl stats --command "git*"          # Filter by command pattern
  wakatermctl stats --start-date 2024-01-01   # Filter by date range
  wakatermctl stats --command-type build      # Filter by command category
  wakatermctl stats --export csv              # Export data as CSV
  
  # Ignore pattern management  
  wakatermctl ignore add "git status"         # Add pattern to ignore
  wakatermctl ignore add "debug_*"            # Add wildcard pattern
  wakatermctl ignore remove "ls"              # Remove pattern
  wakatermctl ignore list                     # List all patterns
  wakatermctl ignore test "git status"        # Test if command would be ignored
  wakatermctl ignore edit                    # Open ignore file in editor
        """
    )
    
    # Add global arguments
    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )
    
    # Create subparsers for stats and ignore commands
    subparsers = parser.add_subparsers(dest="subcommand", help="Available commands")
    
    # Stats subparser (default behavior)
    stats_parser = subparsers.add_parser(
        "stats", 
        help="Show terminal activity statistics (default command)",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Add arguments to stats parser
    stats_parser.add_argument(
        "period",
        nargs="?",
        default="today",
        choices=["today", "yesterday", "last_7_days", "last_30_days", "last_6_months", "last_year"],
        help="Time period for statistics (default: today)"
    )
    
    stats_parser.add_argument(
        "--json",
        action="store_true",
        help="Output raw JSON data instead of formatted display"
    )
    
    stats_parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )
    
    stats_parser.add_argument(
        "--log-dir",
        help="Directory containing wakaterm log files (default: ~/.local/share/wakaterm-logs)"
    )
    
    stats_parser.add_argument(
        "--debug",
        action="store_true",
        help="Show debug information"
    )
    
    stats_parser.add_argument(
        "--project",
        help="Filter by specific project name"
    )
    
    stats_parser.add_argument(
        "--language",
        help="Filter by specific language/technology"
    )
    
    stats_parser.add_argument(
        "--command",
        help="Filter by specific command pattern (supports wildcards)"
    )
    
    stats_parser.add_argument(
        "--min-time",
        type=int,
        help="Minimum seconds to include in analysis (default: 2)"
    )
    
    stats_parser.add_argument(
        "--max-time",
        type=int,
        help="Maximum seconds to include in analysis"
    )
    
    stats_parser.add_argument(
        "--start-date",
        help="Start date for analysis (YYYY-MM-DD format)"
    )
    
    stats_parser.add_argument(
        "--end-date",
        help="End date for analysis (YYYY-MM-DD format)"
    )
    
    stats_parser.add_argument(
        "--hour-range",
        help="Filter by hour range (e.g., '9-17' for 9 AM to 5 PM)"
    )
    
    stats_parser.add_argument(
        "--weekday",
        choices=['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'],
        help="Filter by specific weekday"
    )
    
    stats_parser.add_argument(
        "--command-type",
        choices=['file-ops', 'text-proc', 'version-ctrl', 'build', 'deploy', 'admin', 'network', 'package-mgr'],
        help="Filter by command category"
    )
    
    stats_parser.add_argument(
        "--exclude-project",
        help="Exclude specific project from analysis"
    )
    
    stats_parser.add_argument(
        "--summary",
        action="store_true",
        help="Show only summary statistics"
    )
    
    stats_parser.add_argument(
        "--export",
        choices=["csv", "json", "markdown"],
        help="Export data in specified format"
    )
    
    # Ignore patterns subparser
    ignore_parser = subparsers.add_parser("ignore", help="Manage command ignore patterns")
    ignore_subparsers = ignore_parser.add_subparsers(dest="ignore_action", help="Ignore pattern actions")
    
    # Add pattern
    add_parser = ignore_subparsers.add_parser("add", help="Add an ignore pattern")
    add_parser.add_argument("pattern", help="Pattern to add (supports wildcards like git*, debug_*, etc.)")
    
    # Remove pattern  
    remove_parser = ignore_subparsers.add_parser("remove", help="Remove an ignore pattern")
    remove_parser.add_argument("pattern", help="Pattern to remove")
    
    # List patterns
    list_parser = ignore_subparsers.add_parser("list", help="List all ignore patterns")
    
    # Test pattern
    test_parser = ignore_subparsers.add_parser("test", help="Test if a command would be ignored")
    test_parser.add_argument("test_command", help="Command to test")
    
    # Edit patterns file
    edit_parser = ignore_subparsers.add_parser("edit", help="Open ignore patterns file in editor")
    
    # Clear all patterns
    clear_parser = ignore_subparsers.add_parser("clear", help="Clear all ignore patterns")
    clear_parser.add_argument("--yes", action="store_true", help="Skip confirmation prompt")
    
    # Parse arguments using the configured parser
    try:
        args = parser.parse_args()
    except SystemExit:
        # argparse calls sys.exit on error, let it handle help and errors
        return
    
    # If no subcommand was provided, show help and exit
    if not hasattr(args, 'subcommand') or args.subcommand is None:
        parser.print_help()
        return
    

    
    # Disable colors if requested or if not in a terminal
    use_colors = not args.no_color and sys.stdout.isatty()
    
    try:
        # Handle ignore pattern management
        if args.subcommand == "ignore":
            handle_ignore_commands(args, use_colors)
            return
            
        # For stats commands, ensure we have all required attributes
        stats_defaults = {
            'log_dir': None,
            'debug': False,
            'project': None,
            'language': None,
            'min_time': None,
            'summary': None,
            'export': None,
            'json': None,
            'period': 'today'
        }
        for attr, default in stats_defaults.items():
            if not hasattr(args, attr):
                setattr(args, attr, default)
            
        # Initialize stats reader
        reader = LocalStatsReader(args.log_dir)
        
        # Show debug info if requested
        if args.debug:
            debug_color = "" if not use_colors else Colors.YELLOW
            reset_color = "" if not use_colors else Colors.RESET
            
            print(f"{debug_color}Debug Info:{reset_color}", file=sys.stderr)
            print(f"  Log directory: {reader.log_dir}", file=sys.stderr)
            print(f"  Directory exists: {reader.log_dir.exists()}", file=sys.stderr)
            print(f"  Colors enabled: {use_colors}", file=sys.stderr)
            
            if reader.log_dir.exists():
                log_files = list(reader.log_dir.glob("wakaterm-*.jsonl"))
                print(f"  Log files found: {len(log_files)}", file=sys.stderr)
                for log_file in sorted(log_files)[-5:]:  # Show last 5 files
                    print(f"    {log_file.name}", file=sys.stderr)
            print("", file=sys.stderr)
        
        # Prepare filters
        filters = {}
        if getattr(args, 'project', None):
            filters['project'] = args.project
        if getattr(args, 'language', None):
            filters['language'] = args.language
        if getattr(args, 'command', None):
            filters['command'] = args.command
        if getattr(args, 'min_time', None):
            filters['min_time'] = args.min_time
        if getattr(args, 'max_time', None):
            filters['max_time'] = args.max_time
        if getattr(args, 'start_date', None):
            filters['start_date'] = args.start_date
        if getattr(args, 'end_date', None):
            filters['end_date'] = args.end_date
        if getattr(args, 'hour_range', None):
            filters['hour_range'] = args.hour_range
        if getattr(args, 'weekday', None):
            filters['weekday'] = args.weekday
        if getattr(args, 'command_type', None):
            filters['command_type'] = args.command_type
        if getattr(args, 'exclude_project', None):
            filters['exclude_project'] = args.exclude_project
        
        # Get statistics
        stats = reader.get_stats_for_period(args.period, filters if filters else None)
        
        # Handle export formats
        if args.export:
            StatsFormatter.export_data(stats, args.export, args.period, filters)
            return
        
        if args.json:
            print(json.dumps(stats, indent=2))
            return
        
        # Format and display
        period_names = {
            "today": "Today's Terminal Activity",
            "yesterday": "Yesterday's Terminal Activity", 
            "last_7_days": "Last 7 Days Terminal Activity",
            "last_30_days": "Last 30 Days Terminal Activity",
            "last_6_months": "Last 6 Months Terminal Activity",
            "last_year": "Last Year Terminal Activity"
        }
        
        title = period_names.get(args.period, args.period.replace('_', ' ').title())
        
        # Handle summary mode
        if args.summary:
            formatted_stats = StatsFormatter.format_summary(stats, title or "Terminal Activity", use_colors)
        else:
            formatted_stats = StatsFormatter.format_stats(stats, title or "Terminal Activity", use_colors)
        
        print(formatted_stats)
        
    except KeyboardInterrupt:
        if use_colors:
            print(f"\n{Colors.CYAN}👋 Goodbye!{Colors.RESET}")
        else:
            print("\nGoodbye!")
        sys.exit(0)
    except FileNotFoundError as e:
        error_msg = f"Log directory not found: {e.filename if hasattr(e, 'filename') else 'unknown'}"
        if use_colors:
            print(f"{Colors.RED}❌ {error_msg}{Colors.RESET}", file=sys.stderr)
            print(f"{Colors.YELLOW}💡 Try running some commands first to generate log data, or check --log-dir path{Colors.RESET}", file=sys.stderr)
        else:
            print(f"Error: {error_msg}", file=sys.stderr)
            print("Try running some commands first to generate log data, or check --log-dir path", file=sys.stderr)
        sys.exit(1)
    except PermissionError as e:
        error_msg = f"Permission denied accessing log files: {e.filename if hasattr(e, 'filename') else 'log directory'}"
        if use_colors:
            print(f"{Colors.RED}❌ {error_msg}{Colors.RESET}", file=sys.stderr)
            print(f"{Colors.YELLOW}💡 Check file permissions or run with appropriate privileges{Colors.RESET}", file=sys.stderr)
        else:
            print(f"Error: {error_msg}", file=sys.stderr)
            print("Check file permissions or run with appropriate privileges", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        error_msg = f"Corrupted log file detected: {e}"
        if use_colors:
            print(f"{Colors.RED}❌ {error_msg}{Colors.RESET}", file=sys.stderr)
            print(f"{Colors.YELLOW}💡 Try cleaning up old logs with --cleanup or check log file integrity{Colors.RESET}", file=sys.stderr)
        else:
            print(f"Error: {error_msg}", file=sys.stderr)
            print("Try cleaning up old logs with --cleanup or check log file integrity", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        error_msg = f"Invalid input: {e}"
        if use_colors:
            print(f"{Colors.RED}❌ {error_msg}{Colors.RESET}", file=sys.stderr)
            print(f"{Colors.YELLOW}💡 Check your command arguments and try again{Colors.RESET}", file=sys.stderr)
        else:
            print(f"Error: {error_msg}", file=sys.stderr)
            print("Check your command arguments and try again", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        if getattr(args, 'debug', False):
            import traceback
            traceback.print_exc()
        else:
            error_msg = f"An unexpected error occurred: {e}"
            if use_colors:
                print(f"{Colors.RED}❌ {error_msg}{Colors.RESET}", file=sys.stderr)
                print(f"{Colors.YELLOW}💡 Run with --debug for more details{Colors.RESET}", file=sys.stderr)
            else:
                print(f"Error: {error_msg}", file=sys.stderr)
                print("Run with --debug for more details", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
